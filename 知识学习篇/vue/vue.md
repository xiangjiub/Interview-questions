#### vue组件data要函数形式？
vue组件可能存在多个实例，如果使用对象形式定义data，则会导致他们共用一个data对象，那么状态变更将会影响所有组件实例，这是不合理的；采用函数形式定义，在initData时会将其作为一个工厂函数返回全新data对象，有效规避多实例之间状态污染问题。而在vue跟实例创建过程中则不存在该限制，而是根实例只能有一个，不需要担心这种情况。
#### key的作用和原理。
1. key的作用主要是为了高效的更新虚拟Dom，其原理是vue在patch过程中通过key可以精准的判断两个节点是否是同一个，从而避免频繁的更新不同元素，使得整个patch过程更加高效，减少DOM操作量，提高性能。
2. 另外，若不设置key还可能在列表更新时引发一些屏蔽的bug。
3. vue中在使用相同标签名元的过渡切换时，也会使用到key属性，其目的也是为了让vue可以区分他们，否则vue只会在替换内部属性而不会触发过渡效果。
#### 怎么看vue中diff算法
1. diff算法是虚拟DOM技术的必然产物，通过新旧虚拟Dom做对比(即diff)，将变化的地方更新在真实Dom上，另外，也需要diff高效的执行对比过程，从而降低时间复杂度为O(n)
2. vue2.x中为了降低Watcher粒度，每个组件只有一个Watcher与之对应，只有引入diff才能精确找到发生变化的地方。
3. vue中diff执行的时刻是组件实例执行其更新函数时，他会对比上一次渲染结果oldVnode和新的渲染结果newVnode，此过程称为patch。
4. diff过程遵循深度优先、同层比较的策略；两个节点之间比较会根据他们是否时子节点或者文本节点做不同的操作。
#### 对vue组件化的理解？
1. 组件是独立和可复用的代码组织单元。组件系统是vue核心特性之一，它使开发者使用小型、独立和通常可复用的组件构建大型应用。
2. 组件化开发能大幅提高应用开发效率、测试性、复用性等
3. 组件使用按分类有：页面组件、业务组件、通用组件
4. vue的组件是基于配置的，我们通常写的组件是组件配置而非组件，框架后续会生成其构造函数，它们基于vueComponent，扩展Vue
5. vue常见的组件化技术有：prop，自定义事件，插槽等，他们主要是用于组件通信、扩展等
6. 遵循单向数据流的原则
#### 对vue设计原则的理解？
1. 易用

已经会了 HTML、CSS、JavaScript？即刻阅读指南开始构建应用！

2. 灵活

不断繁荣的生态系统，可以在一个库和一套完整框架之间自如伸缩。

3. 高效

20kB min+gzip 运行大小、超快虚拟 DOM、最省心的优化
#### MVC、MVVM、
![mvvm](1.png)
![](2.png)

#### vue中组件之间的通信
1. 父子组件通信 props
2. 兄弟组件通信 vuex
3. 跨层组件通信 provide inject
#### vue性能优化方法？
1. 路由懒加载
2. keep-alive （缓存页面）
3. 使用v-show复用Dom
4. v-for 遍历避免同时使用v-if。用计算属性
5. 如果是大数据长列表，可采用虚拟滚动，只渲染少部分区域的内容（vue-virtual-scroller）
6. 事件的销毁：vue组件销毁时，会自动解绑它的全部指令及事件监听器，但是仅限于组件本身的事件。（虽然会自己销毁）
7. 图片懒加载：可视区域优先加载。
8. 第三方插件按需引入
9. 无状态的组件标记为函数式组件(没有引入vue)
![无状态组件](3.png)
10. 子组件分割
![子组件分割](4.png)
11. 变量的本地化(图中的base)
![变量本地化](5.png)
12. ssr

#### vue3 新特性
1. 更快
    * 虚拟DOM重写
    * 优化slots的生成
    * 静态树的提升
    * 基于Proxy的响应式
2. 更小：通过摇树优化核心库体积
3. 更容易维护： ts+模块化
4. 更加友好
    * 跨平台：编译器核心和运行时核心与平台无关，使得Vue更容易与任何平台（ios等）一起使用
5. 更容易使用
    * 改进ts的支持
    * 更好的调试支持
    * 独立响应式模块
    * Composition API

#### watch和computed的区别及使用
watch 需要在数据变化时执行异步或开销较大的操作时，简单讲，当一条数据影响多条数据，例如搜索数据。监听
computed 对于任何复杂逻辑或一个数据属性在它所依赖的属性发生变化时，也要发生变化时。计算属性
#### 对vue生命周期的理解
mounted中并不会保证所有子组件都被挂载完成后再触发，因此当你希望视图完全渲染完成后再做某些事情时，请在mounted中使用$nextTick。

#### js事件循环
js处理异步主要有微任务和宏任务，而从一开始执行一个宏任务 => 执行完这个宏任务中所有的同步代码 => 清空当前微任务队列中所有微任务 => UI渲染。这就是一个事件循环。然后开始执行下一个宏任务（相当于下一轮循环。）
#### nextTick实现原理？
理解：（宏任务和微任务）异步方法
nextTick方法主要是使用了宏任务和微任务。定义了一个异步方法，多次调用nextTick会将方法存放到队列中，通过这个异步方法清空当前队列，所以这个nextTick方法就是异步方法。

**nextTick 可以让我们在下次 DOM 更新循环结束之后执行延迟回调，用于获得更新后的 DOM。**

***参考***
<!-- https://blog.csdn.net/weixin_42707287/article/details/111931861 -->
[](https://blog.csdn.net/weixin_42707287/article/details/111931861)

#### vue DOM更新为什么是异步的？
```vue
changeValue () {
    this.message = 'hello zhangShan'
    this.message = 'hello liShi'
    this.message = 'hello wangWu'
    this.message = 'hello chenLiu'
    console.log(this.$refs.dom.innerText)
}
```
上图这样，如果vue同步更新的话，将会造成4次dom更新。故vue是异步dom更新的

***原理：***
Vue在更新Dom时是异步执行的。只要监听到数据变化，Vue将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个Watcher被多次触发，只会被推入队列中一次。这种缓冲时去除重复数据对于避免不必要的计算和DOM操作是非常重要的。然后，在下一个的事件循环“tick”中，Vue刷新队列并执行实际（已去重的）工作。Vue在内部对异步队列尝试使用原生的Promise.then、MutationObserver（mutationObserver在vue2.5以后被弃用） 和 setImmediate，如果执行环境不支持，则会采用 setTimeout(fn, 0) 代替。

#### watch computed 区别


#### Proxy
const p = new Proxy(target, handler)
* target 

    要使用 Proxy 包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）。

* handler

    一个通常以函数作为属性的对象，各属性中的函数分别定义了在执行各种操作时代理 p 的行为。
    <!-- 一个通常以函数作为属性的对象，用来定制拦截行为 -->

1. 模板是怎么编绎的?
2. 生命周期是怎么挂载的?
3. 组件是怎么注册的?
4. 响应式怎么做到的?


#### Vue把虚拟dom(vnode)转化为真实dom的过程
第一步拿到我们写的template模版，通过complie编译成AST抽象语法树
第二部通过createElement方法把语法书转换为vnode
最后就是通过render方法把vnode变为真实dom
![](真是dom.png)

#### js运行机制
（1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。

（2）主线程之外，还存在一个"任务队列"（task queue）。只要异步任务有了运行结果，就在"任务队列"之中放置一个事件。

（3）一旦"执行栈"中的所有同步任务执行完毕，系统就会读取"任务队列"，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。

（4）主线程不断重复上面的第三步

#### 组件渲染和更新过程？
渲染组件时，会通过Vue.extend 方法构建子组件的构造函数，并进行实例化。最终手动调用 $mount()进行挂载。更新组件时会进行patchVnode流程。核心就时diff算法。

#### 事件绑定的原理?
vue的事件绑定分为两种。一种原生事件的绑定。一种是组件的事件绑定。

1. 原生的dom事件绑定采用的是addEventListener实现的
2. 组件绑定事件采用的是$on方法